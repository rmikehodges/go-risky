package database_test

import (
	"context"
	"go-risky/database"
	"go-risky/types"
	"testing"

	"github.com/go-playground/assert"
	"github.com/google/uuid"
	"github.com/jackc/pgx/v5/pgxpool"
)

func TestGetVulnerabilities(t *testing.T) {
	poolConfig, _ := pgxpool.ParseConfig("postgres://postgres:postgres@localhost/risky")
	pgPool, err := pgxpool.NewWithConfig(context.Background(), poolConfig)
	if err != nil {
		panic(err)
	}
	defer pgPool.Close()
	dbManager := &database.DBManager{DBPool: pgPool}
	vulnerabilities, _ := dbManager.GetVulnerabilities(businessId)

	for _, vulnerability := range vulnerabilities {
		assert.Equal(t, vulnerability.BusinessID.String(), businessId)
	}
}

func TestGetVulnerability(t *testing.T) {
	var vulnerabilityId = "7c9fb1e7-9c92-4224-b8a0-fd7e4cba4a1e"
	poolConfig, _ := pgxpool.ParseConfig("postgres://postgres:postgres@localhost/risky")
	pgPool, err := pgxpool.NewWithConfig(context.Background(), poolConfig)
	if err != nil {
		panic(err)
	}
	defer pgPool.Close()
	dbManager := &database.DBManager{DBPool: pgPool}
	vulnerability, _ := dbManager.GetVulnerability(vulnerabilityId)

	assert.Equal(t, vulnerability.ID.String(), vulnerabilityId)
}

func TestCreateVulnerability(t *testing.T) {
	poolConfig, _ := pgxpool.ParseConfig("postgres://postgres:postgres@localhost/risky")
	pgPool, err := pgxpool.NewWithConfig(context.Background(), poolConfig)
	if err != nil {
		panic(err)
	}
	defer pgPool.Close()
	dbManager := &database.DBManager{DBPool: pgPool}
	vulnerabilityInput := types.Vulnerability{Name: "test", BusinessID: uuid.MustParse(businessId)}
	vulnerabilityId, err := dbManager.CreateVulnerability(vulnerabilityInput)

	assert.Equal(t, err, nil)

	vulnerability, err := dbManager.GetVulnerability(vulnerabilityId)

	assert.Equal(t, err, nil)

	assert.Equal(t, vulnerability.ID.String(), vulnerabilityId)
}

func TestDeleteVulnerability(t *testing.T) {
	poolConfig, _ := pgxpool.ParseConfig("postgres://postgres:postgres@localhost/risky")
	pgPool, err := pgxpool.NewWithConfig(context.Background(), poolConfig)
	if err != nil {
		panic(err)
	}
	defer pgPool.Close()
	dbManager := &database.DBManager{DBPool: pgPool}
	vulnerabilityInput := types.Vulnerability{Name: "test", BusinessID: uuid.MustParse(businessId)}
	vulnerabilityId, _ := dbManager.CreateVulnerability(vulnerabilityInput)

	err = dbManager.DeleteVulnerability(vulnerabilityId)

	assert.Equal(t, err, nil)

	_, err = dbManager.GetVulnerability(vulnerabilityId)

	assert.NotEqual(t, err, nil)

}

func TestUpdateVulnerability(t *testing.T) {
	poolConfig, _ := pgxpool.ParseConfig("postgres://postgres:postgres@localhost/risky")
	pgPool, err := pgxpool.NewWithConfig(context.Background(), poolConfig)
	if err != nil {
		panic(err)
	}
	defer pgPool.Close()
	dbManager := &database.DBManager{DBPool: pgPool}
	createVulnerabilityInput := types.Vulnerability{Name: "test", BusinessID: uuid.MustParse(businessId)}
	vulnerabilityId, _ := dbManager.CreateVulnerability(createVulnerabilityInput)

	updateVulnerabilityInput := createVulnerabilityInput
	updateVulnerabilityInput.Name = "test2"
	updateVulnerabilityInput.ID = uuid.MustParse(vulnerabilityId)

	err = dbManager.UpdateVulnerability(updateVulnerabilityInput)

	assert.Equal(t, err, nil)

	updatedVulnerability, _ := dbManager.GetVulnerability(vulnerabilityId)

	assert.Equal(t, updateVulnerabilityInput.ID, updatedVulnerability.ID)
}
